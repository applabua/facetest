<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye‚ÄëTracker Debug v3</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background:#000; color:#0f0; }
    #video, #canvas {
      position:absolute; top:0; left:0;
      width:100vw; height:auto;
    }
    #video { opacity:1; z-index:1; }
    #canvas { z-index:2; }
    #cursor {
      position:absolute; width:30px; height:30px;
      border:2px solid #f00; border-radius:50%;
      pointer-events:none; transform:translate(-50%,-50%);
      z-index:3;
    }
    #status {
      position:absolute; top:0; right:0;
      background:rgba(0,0,0,0.7); padding:4px 8px;
      z-index:4;
    }
    #log {
      position:absolute; bottom:0; left:0;
      width:100%; max-height:120px; overflow-y:auto;
      background:rgba(0,0,0,0.8); padding:4px; font-family:monospace;
      z-index:5;
    }
    #btn {
      position:absolute; bottom:40px; left:50%;
      transform:translateX(-50%);
      padding:12px 24px; font-size:18px;
      background:#007aff; color:#fff; border:none; border-radius:8px;
      z-index:6;
    }
  </style>
</head>
<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<div id="cursor"></div>
<button id="btn">–ù–∞–∂–º–∏ –≤–∑–≥–ª—è–¥–æ–º</button>
<div id="status">–°—Ç–∞—Ç—É—Å: ‚Ä¶</div>
<pre id="log">LOG:</pre>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.8.0/dist/tf-core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.8.0/dist/tf-backend-webgl.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.2/dist/face-landmarks-detection.min.js"></script>

<script>
(async ()=>{
  const logEl = document.getElementById('log');
  const statusEl = document.getElementById('status');
  function log(msg){
    logEl.textContent += '\n'+msg;
    logEl.scrollTop = logEl.scrollHeight;
  }

  // –ò–Ω–∏—Ü–∏–∞—Ü–∏—è TF.js
  await tf.setBackend('webgl'); await tf.ready();
  log('TF.js backend='+tf.getBackend());

  // –ö–∞–º–µ—Ä–∞
  let stream;
  try {
    log('–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É‚Ä¶');
    stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user', width:480, height:360 } });
    log('–ö–∞–º–µ—Ä–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞.');
  } catch(e){
    log('–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã: '+e.name+' '+e.message);
    statusEl.textContent='–°—Ç–∞—Ç—É—Å: –Ω–µ—Ç –∫–∞–º–µ—Ä—ã';
    return;
  }
  const video = document.getElementById('video');
  video.srcObject = stream;
  await new Promise(r=> video.onloadedmetadata = r);
  log(`–í–∏–¥–µ–æ: ${video.videoWidth}√ó${video.videoHeight}`);

  // Canvas –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
  const canvas = document.getElementById('canvas');
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  const ctx = canvas.getContext('2d');

  // –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ facemesh
  log('–ó–∞–≥—Ä—É–∂–∞–µ–º facemesh‚Ä¶');
  const model = await faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages.facemesh);
  log('–ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞.');

  const cursor = document.getElementById('cursor');
  const btn = document.getElementById('btn');
  let lastBlink=0, BLINK_INTERVAL=1000;

  function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }
  function isBlink(u,l,le,ri){ return dist(u,l)/dist(le,ri)<0.25; }

  async function loop(){
    // –ø–æ–ª—É—á–∞–µ–º –º–µ—à
    const faces = await model.estimateFaces({ input:video, returnTensors:false, flipHorizontal:true });
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(faces.length){
      statusEl.textContent='–°—Ç–∞—Ç—É—Å: –õ–∏—Ü–æ –Ω–∞–π–¥–µ–Ω–æ';
      const kp = faces[0].scaledMesh;

      // —Ä–∏—Å—É–µ–º –ø–µ—Ä–≤—ã–µ 20 —Ç–æ—á–µ–∫ –º–µ—à–∞
      ctx.fillStyle='yellow';
      for(let i=0; i<20; i++){
        const [x,y] = kp[i];
        ctx.fillRect(x-1,y-1,3,3);
      }

      // —Ä–∏—Å—É–µ–º bounding box
      const box = faces[0].boundingBox;
      const [x1,y1] = box.topLeft[0], [x2,y2] = box.bottomRight[0];
      ctx.strokeStyle='lime'; ctx.lineWidth=2;
      ctx.strokeRect(x1,y1, x2-x1, y2-y1);

      // —Å—á–∏—Ç–∞–µ–º –≤–∑–≥–ª—è–¥
      const L=[33,133,159,145], R=[362,263,386,374];
      const leftC  ={x:(kp[L[0]][0]+kp[L[1]][0])/2, y:(kp[L[0]][1]+kp[L[1]][1])/2};
      const rightC ={x:(kp[R[0]][0]+kp[R[1]][0])/2, y:(kp[R[0]][1]+kp[R[1]][1])/2};
      const gaze   ={x:(leftC.x+rightC.x)/2, y:(leftC.y+rightC.y)/2};
      const sx = gaze.x/video.videoWidth * window.innerWidth;
      const sy = gaze.y/video.videoHeight* window.innerHeight;
      cursor.style.left=sx+'px'; cursor.style.top=sy+'px';

      // blink
      const blinkL = isBlink({x:kp[L[2]][0],y:kp[L[2]][1]}, {x:kp[L[3]][0],y:kp[L[3]][1]}, leftC, rightC);
      const blinkR = isBlink({x:kp[R[2]][0],y:kp[R[2]][1]}, {x:kp[R[3]][0],y:kp[R[3]][1]}, leftC, rightC);
      const now = performance.now();
      if(blinkL && blinkR && now-lastBlink>BLINK_INTERVAL){
        lastBlink=now;
        const rect=btn.getBoundingClientRect();
        if(sx>=rect.left && sx<=rect.right && sy>=rect.top && sy<=rect.bottom){
          log('üëâ Click by blink');
          btn.click();
        }
      }
    } else {
      statusEl.textContent='–°—Ç–∞—Ç—É—Å: –õ–∏—Ü–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ';
    }

    requestAnimationFrame(loop);
  }

  btn.addEventListener('click',()=>alert('–ö–Ω–æ–ø–∫–∞ –Ω–∞–∂–∞—Ç–∞!'));
  loop();

})();
</script>

</body>
</html>
